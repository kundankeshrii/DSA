//700. Search in a Binary Search Tree
https://leetcode.com/problems/search-in-a-binary-search-tree/description/
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public TreeNode searchBST(TreeNode root, int val) {
        while(root!=null && root.val!=val){
            if(val<root.val){
                root=root.left;
            }else{
                root=root.right;
            }
        }
        return root;
    }
}
//701. Insert into a Binary Search Tree
https://leetcode.com/problems/insert-into-a-binary-search-tree/description/
class Solution {
    public TreeNode insertIntoBST(TreeNode root, int val) {
        if(root==null) return new TreeNode(val);
        TreeNode curr=root;
        while(true){
            if(curr.val<=val){
                if(curr.right!=null) curr=curr.right;
                else{
                    curr.right=new TreeNode(val);
                    break;
                }
            }else{
                if(curr.left!=null) curr=curr.left;
                else{
                    curr.left=new TreeNode(val);
                    break;
                }
            }
        }
        return root;
    }
}
//450. Delete Node in a BST
https://leetcode.com/problems/delete-node-in-a-bst/description/
class Solution {
    public TreeNode deleteNode(TreeNode root, int key) {
        if(root==null) return null;
        if(root.val==key){ 
            return helper(root);
        }
        TreeNode dummy=root;
        while(root!=null){
            if(root.val>key){
                if(root.left!=null && root.left.val==key){
                    root.left=helper(root.left);
                    break;
                }else{
                root=root.left;
                }   
            }else{
                if(root.right!=null && root.right.val==key){
                    root.right=helper(root.right);
                    break;
                }else{
                    root=root.right;
                }
            }
        }
        return dummy;
        }
        private TreeNode helper(TreeNode root){
            if(root.left==null) return root.right;
            else if(root.right==null){
                return root.left;
            }else{
                TreeNode rightChild=root.right;
                TreeNode lastRight=findLastRight(root.left);
                lastRight.right=rightChild;
            }
            return root.left;
        }
        private TreeNode findLastRight(TreeNode root){
            if(root.right==null){
                return root;
            }
            return findLastRight(root.right);
        }
}
//230. Kth Smallest Element in a BST
https://leetcode.com/problems/kth-smallest-element-in-a-bst/description/
class Solution {
    public int kthSmallest(TreeNode root, int k) {
        TreeNode curr=root;
        while(curr!=null){
            if(curr.left==null){
                k--;
                if(k==0) return curr.val;
                curr=curr.right;
            }else{
                TreeNode prev=curr.left;
                while(prev.right!=null && prev.right!=curr){
                    prev=prev.right;
                }
                if(prev.right==null){
                    prev.right=curr;
                     curr=curr.left;
                }else{
                    prev.right=null;
                    k--;
                    if(k==0) return curr.val;
                     curr=curr.right;
                }
            }
        }
        return -1;
    }
}
//98. Validate Binary Search Tree
https://leetcode.com/problems/validate-binary-search-tree/description/
class Solution {
    public boolean isValidBST(TreeNode root) {
        return isValidBST(root,Long.MIN_VALUE,Long.MAX_VALUE);
    }
    private boolean isValidBST(TreeNode root, long minValue,long maxValue){
        if(root==null) return true;
        if(root.val>=maxValue || root.val<=minValue){
            return false;
        }
        return isValidBST(root.left,minValue,root.val) && isValidBST(root.right,root.val,maxValue);
    }
}
//235. Lowest Common Ancestor of a Binary Search Tree
https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-search-tree/description/
class Solution {
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        if(root==null) return null;
        int curr=root.val;
        if(curr<p.val &&curr<q.val){
            return lowestCommonAncestor(root.right,p,q);
        }
        if(curr>p.val && curr>q.val){
            return lowestCommonAncestor(root.left,p,q);
        }
        return root;
    }
}
