//700. Search in a Binary Search Tree
https://leetcode.com/problems/search-in-a-binary-search-tree/description/
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public TreeNode searchBST(TreeNode root, int val) {
        while(root!=null && root.val!=val){
            if(val<root.val){
                root=root.left;
            }else{
                root=root.right;
            }
        }
        return root;
    }
}
//701. Insert into a Binary Search Tree
https://leetcode.com/problems/insert-into-a-binary-search-tree/description/
class Solution {
    public TreeNode insertIntoBST(TreeNode root, int val) {
        if(root==null) return new TreeNode(val);
        TreeNode curr=root;
        while(true){
            if(curr.val<=val){
                if(curr.right!=null) curr=curr.right;
                else{
                    curr.right=new TreeNode(val);
                    break;
                }
            }else{
                if(curr.left!=null) curr=curr.left;
                else{
                    curr.left=new TreeNode(val);
                    break;
                }
            }
        }
        return root;
    }
}
//450. Delete Node in a BST
https://leetcode.com/problems/delete-node-in-a-bst/description/
class Solution {
    public TreeNode deleteNode(TreeNode root, int key) {
        if(root==null) return null;
        if(root.val==key){ 
            return helper(root);
        }
        TreeNode dummy=root;
        while(root!=null){
            if(root.val>key){
                if(root.left!=null && root.left.val==key){
                    root.left=helper(root.left);
                    break;
                }else{
                root=root.left;
                }   
            }else{
                if(root.right!=null && root.right.val==key){
                    root.right=helper(root.right);
                    break;
                }else{
                    root=root.right;
                }
            }
        }
        return dummy;
        }
        private TreeNode helper(TreeNode root){
            if(root.left==null) return root.right;
            else if(root.right==null){
                return root.left;
            }else{
                TreeNode rightChild=root.right;
                TreeNode lastRight=findLastRight(root.left);
                lastRight.right=rightChild;
            }
            return root.left;
        }
        private TreeNode findLastRight(TreeNode root){
            if(root.right==null){
                return root;
            }
            return findLastRight(root.right);
        }
}
//230. Kth Smallest Element in a BST
https://leetcode.com/problems/kth-smallest-element-in-a-bst/description/
class Solution {
    public int kthSmallest(TreeNode root, int k) {
        TreeNode curr=root;
        while(curr!=null){
            if(curr.left==null){
                k--;
                if(k==0) return curr.val;
                curr=curr.right;
            }else{
                TreeNode prev=curr.left;
                while(prev.right!=null && prev.right!=curr){
                    prev=prev.right;
                }
                if(prev.right==null){
                    prev.right=curr;
                     curr=curr.left;
                }else{
                    prev.right=null;
                    k--;
                    if(k==0) return curr.val;
                     curr=curr.right;
                }
            }
        }
        return -1;
    }
}
//98. Validate Binary Search Tree
https://leetcode.com/problems/validate-binary-search-tree/description/
class Solution {
    public boolean isValidBST(TreeNode root) {
        return isValidBST(root,Long.MIN_VALUE,Long.MAX_VALUE);
    }
    private boolean isValidBST(TreeNode root, long minValue,long maxValue){
        if(root==null) return true;
        if(root.val>=maxValue || root.val<=minValue){
            return false;
        }
        return isValidBST(root.left,minValue,root.val) && isValidBST(root.right,root.val,maxValue);
    }
}
//235. Lowest Common Ancestor of a Binary Search Tree
https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-search-tree/description/
class Solution {
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        if(root==null) return null;
        int curr=root.val;
        if(curr<p.val &&curr<q.val){
            return lowestCommonAncestor(root.right,p,q);
        }
        if(curr>p.val && curr>q.val){
            return lowestCommonAncestor(root.left,p,q);
        }
        return root;
    }
}
//1008. Construct Binary Search Tree from Preorder Traversal
https://leetcode.com/problems/construct-binary-search-tree-from-preorder-traversal/description/
class Solution {
    public TreeNode bstFromPreorder(int[] preorder) {
        return fun(preorder,Integer.MAX_VALUE,new int[]{0});
    }
    private TreeNode fun(int[] preorder,int bound,int[] i){
        if(i[0]==preorder.length || preorder[i[0]]>bound) return null;
    
        TreeNode root=new TreeNode(preorder[i[0]]);
        root.left=fun(preorder,root.val,i);
        root.right=fun(preorder,bound,i);
        return root;
    }
}
//653. Two Sum IV - Input is a BST
https://leetcode.com/problems/two-sum-iv-input-is-a-bst/description/
class Solution {
    public boolean findTarget(TreeNode root, int k) {
        if(root==null) return false;
        BSTIterator l=new BSTIterator(root,false);
        BSTIterator r=new BSTIterator(root,true);
        int i=l.next();
        int j=r.next();
        while(i<j){
            if(i+j==k) return true;
            else if(i+j<k) i=l.next();
            else j=r.next();
        }
        return false;
    }
}
class BSTIterator{
    Stack<TreeNode>st=new Stack<>();
    boolean reverse=true;
    BSTIterator(TreeNode root,boolean isReverse){
        reverse=isReverse;
        pushAll(root);
    }
    public boolean hasNext(){
        return !st.isEmpty();
    }
    public int next(){
        TreeNode temp=st.pop();
        if(reverse== false) pushAll(temp.right);
        else{
            pushAll(temp.left);
        }
        return temp.val;
    }
    private void pushAll(TreeNode node){
        while(node!=null){
            st.push(node);
            if(reverse==true) node=node.right;
            else node=node.left;
        }
    }
}
//99. Recover Binary Search Tree
https://leetcode.com/problems/recover-binary-search-tree/description/
class Solution {
    private TreeNode first;
    private TreeNode prev;
    private TreeNode middle;
    private TreeNode last;
    private void inorder(TreeNode root){
        if(root==null) return;
        inorder(root.left);
        if(prev!=null && root.val<prev.val){
            if(first==null){
                first=prev;
                middle=root;
            }else{
                last=root;
            }
        }
            prev=root;
            inorder(root.right);
        }
    public void recoverTree(TreeNode root) {
        first=middle=last=null;
        prev=new TreeNode(Integer.MIN_VALUE);
        inorder(root);
        if(first!=null && last!=null){
            int temp=first.val;
            first.val=last.val;
            last.val=temp;
        }else if(first!=null && middle!=null){
             int temp=first.val;
            first.val=middle.val;
            middle.val=temp;
        }
    }
}
//449. Serialize and Deserialize BST
//copy Pasted with BT wala question 
https://leetcode.com/problems/serialize-and-deserialize-bst/
public class Codec {

    // Encodes a tree to a single string.
    public String serialize(TreeNode root) {
        if(root==null) return " ";
        Queue<TreeNode>q=new LinkedList<>();
        StringBuilder str=new StringBuilder();
        q.add(root);
        while(!q.isEmpty()){
            TreeNode node=q.poll();
            if(node==null){
                str.append("# ");
            continue;
            }
            str.append(node.val+" ");
            q.add(node.left);
            q.add(node.right);
        }
        return str.toString();
    }

    // Decodes your encoded data to tree.
    public TreeNode deserialize(String data) {
          if(data==" ") return null;
        Queue<TreeNode>q=new LinkedList<>();
        String[] values=data.split(" ");
        TreeNode root=new TreeNode(Integer.parseInt(values[0]));
        q.add(root);
        for(int i=1;i<values.length;i++){
            TreeNode parent=q.poll();
            if(!values[i].equals("#")){
                TreeNode left=new TreeNode(Integer.parseInt(values[i]));
                parent.left=left;
                q.add(left);
            }
            if(!values[++i].equals("#")){
                TreeNode right=new TreeNode(Integer.parseInt(values[i]));
                parent.right=right;
                q.add(right);
            }
        }
        return root;
    
    }
}
