//Q11.Leetcode
//https://leetcode.com/problems/container-with-most-water/description/
//Using Two Pointer Approach
class Solution {
    public int maxArea(int[] height) {
        int i=0;
        int j=height.length-1;
        int maxWater=0;
        while(i<j){
            int width=j-i;
            int heightt=Math.min(height[i],height[j]);
            int area=width*heightt;
            maxWater=Math.max(maxWater,area);
            if(height[i]<height[j]){
                i++;
            }else{
                j--;
            }
        }
        return maxWater;
    }
}

//https://leetcode.com/problems/next-permutation/description/
//leetcode Q.31
//solved using Two pointer approach
class Solution {
         private void swap(int[] arr,int a,int b){
          int temp=arr[a];
          arr[a]=arr[b];
          arr[b]=temp;
     }
     private void reverse(int[] arr,int start,int end){
        
        while(start<end){
            swap(arr,start,end);
            start++;end--;
        }
     }
    public void nextPermutation(int[] nums) {
        int idx=-1;
        int n=nums.length;
        for(int i=n-2;i>=0;i--){
            if(nums[i]<nums[i+1]){
                idx=i;
                break;
                                }
            }
            if(idx==-1){
                reverse(nums,0,n-1);
                System.out.println(Arrays.toString(nums));
                return;
            }
            for(int j=n-1;j>idx;j--){
                if(nums[j]>nums[idx]){
                    swap(nums,j,idx);
                    break;
                }
            }
            reverse(nums,idx+1,n-1);
            System.out.println(Arrays.toString(nums));
        }
    
}


//https://leetcode.com/problems/combination-sum/

class Solution {
    public List<List<Integer>> combinationSum(int[] candidates, int target) {
        return CS(candidates,candidates.length-1,target);
    }
    private List<List<Integer>> CS(int[] arr,int n,int target){
        List<List<Integer>> result=new ArrayList<>();
        
        if(target==0) {
            result.add(new ArrayList<>());
            return result;
        }
        if(target<0 || n<0 ) return result;
        //exclude
         
        List<List<Integer>> exclude= CS(arr,n-1,target);
        //include
         List<List<Integer>> include= CS(arr,n,target-arr[n]);
         for(List<Integer> list: include){
            list.add(0,arr[n]);
            result.add(list);
         }
         result.addAll(exclude);
         return result;

         }
    
}


//https://leetcode.com/problems/subsets/description/

class Solution {
    public List<List<Integer>> subsets(int[] nums) {
        return powerSet(nums,0,new ArrayList<>());
    }
   
    private List<List<Integer>> powerSet(int[] nums,int idx,List<Integer> curr ){
        if(idx==nums.length){
             List<List<Integer>> list=new ArrayList<>();
             list.add(new ArrayList<>(curr));
             return list;

        }//exclude
         List<List<Integer>> exclude=powerSet(nums,idx+1,curr);
         //include
         curr.add(nums[idx]);
         List<List<Integer>> include=powerSet(nums,idx+1,curr);
         curr.remove(curr.size()-1);

         //merge result
         exclude.addAll(include);
         return exclude;


    }

}


//https://leetcode.com/problems/combination-sum-ii/description/

class Solution {
    public List<List<Integer>> combinationSum2(int[] candidates, int target) {
        Arrays.sort(candidates); 
        return CS(candidates, candidates.length - 1, target);
    }

    private List<List<Integer>> CS(int[] arr, int idx, int target) {
        List<List<Integer>> result = new ArrayList<>();

        if (target == 0) {
            result.add(new ArrayList<>());  
            return result;
        }
        if (target < 0 || idx < 0) {
            return result;  
        }

        //Exclude 
        int newIdx = idx - 1;
        // skip  
        while (newIdx >= 0 && arr[newIdx] == arr[idx]) {
            newIdx--;
        }
        List<List<Integer>> exclude = CS(arr, newIdx, target);

        // Include 
        List<List<Integer>> include = CS(arr, idx - 1, target - arr[idx]);
        for (List<Integer> list : include) {
            list.add(0, arr[idx]);
            result.add(list);
        }

        result.addAll(exclude);
        return result;
    }
}

//Backtracking with Constraints
//https://leetcode.com/problems/generate-parentheses/description/
class Solution {
    public List<String> generateParenthesis(int n) {
        List<String>list=new ArrayList<String>();
         helper( list,"",0,0,n);
        return list;
         

    }
    private void helper( List<String>list,String str,int open,int close,int max){
        if(str.length()==2*max){
            list.add(str);
        }
        if(open<max){
        helper(list,str+"(",open+1,close,max);
        }
        if(close<open){
        helper(list,str+")",open,close+1,max);
    }
    

    }
}


//https://leetcode.com/problems/subsets-ii/
class Solution {
    public List<List<Integer>> subsetsWithDup(int[] nums) {
        Arrays.sort(nums);
        List<List<Integer>>result=new ArrayList<>();
        powerSet(nums,0,new ArrayList<>(),result);
        return result;
    }

    private List<List<Integer>> powerSet(int[] nums,int idx,List<Integer> ds,List<List<Integer>>result ){
            result.add(new ArrayList<>(ds));
        for(int i=idx;i<nums.length;i++){
            if(i!=idx && nums[i]== nums[i-1]) continue;
                ds.add(nums[i]);
                powerSet(nums,i+1,ds,result);
                ds.remove(ds.size()-1);
            }
            return result;
        }
}

https://leetcode.com/problems/palindrome-partitioning/description/
class Solution {
    public List < List < String >> partition(String s) {
        List < List < String >> res = new ArrayList < > ();
        List < String > path = new ArrayList < > ();
        helper(0, s, path, res);
        return res;
    }

    private void helper(int index, String s, List < String > path, List < List < String >> res) {
        if (index == s.length()) {
            res.add(new ArrayList < > (path));
            return;
        }
        for (int i = index; i < s.length(); ++i) {
            if (isPalindrome(s, index, i)) {
                path.add(s.substring(index, i + 1));
                helper(i + 1, s, path, res);
                path.remove(path.size() - 1);
            }
        }
    }

    private boolean isPalindrome(String s, int start, int end) {
        while (start <= end) {
            if (s.charAt(start++) != s.charAt(end--))
                return false;
        }
        return true;
    }
}

https://leetcode.com/problems/permutation-sequence/

class Solution {
    public String getPermutation(int n, int k) {
        int fact=1;
        List<Integer> list=new ArrayList<>();
        for(int i=1;i<n;i++){
            fact=fact * i;
            list.add(i);
        }
        list.add(n);
        String ans="";
        k=k-1; //Asssuming 0-based indexing
        while(true){
            ans=ans+list.get(k/fact);
            list.remove(k/fact);
            if(list.size()==0){
                break;
            }
            k=k%fact;
            fact=fact/list.size();
        }
        return ans;
    }
}
//42. Trapping Rain Water
//using two pointer approach 
class Solution {
    public int trap(int[] height) {
        int lMax=0,rMax=0,total=0,l=0,r=height.length-1;
        while(l<r){
            if(height[l]<=height[r]){
                if(lMax>height[l]){
                    total+=lMax-height[l];
                }else{
                    lMax=height[l];
                }
                l=l+1;
            }else{
                if(rMax>height[r]){
                    total+=rMax-height[r];
                }else{
                    rMax=height[r];
                }
                r=r-1;
            }
        }
        return total;
    }
}
//M-2
class Solution {
    public int trap(int[] height) {
        int n=height.length;
        int total=0;
        int[] prefix=leftMax(height);
        int[] suffix=rightMax(height);
        for(int i=0;i<height.length;i++){
            if(height[i]<prefix[i] && height[i]<suffix[i]){
                total+=Math.min(prefix[i],suffix[i])-height[i];
            }
        }
        return total;
    }
        private int[] leftMax(int[] height){
            int n=height.length;
            int[] prefix=new int[n];
            prefix[0]=height[0];
            for(int i=1;i<n;i++){
                prefix[i]=Math.max(prefix[i-1],height[i]);
            }
            return prefix;
        }
        private int[] rightMax(int[] height){
            int n=height.length;
            int[] suffix=new int[n];
            suffix[n-1]=height[n-1];
            for(int i=n-2;i>=0;i--){
                suffix[i]=Math.max(suffix[i+1],height[i]);
            }
            return suffix;
        }
}
//796. Rotate String
https://leetcode.com/problems/rotate-string/description/
class Solution {
    public boolean rotateString(String s, String goal) {
        if(s.length()!=goal.length()) return false;
        StringBuilder str=new StringBuilder(s);
        for(int i=0;i<str.length();i++){
            char first=str.charAt(0);
            str.deleteCharAt(0);
            str.append(first);
            if(str.toString().equals(goal)){
                return true;
            }
        }
        return false;
    }
}
//1015. Smallest Integer Divisible by K
https://leetcode.com/problems/smallest-integer-divisible-by-k
class Solution {
    public int smallestRepunitDivByK(int k) {
        int r=0;
        for(int len=1;len<=k;len++){
            r=(r*10+1)%k;
            if (r==0) return len;
    }
    return -1;
}
}
