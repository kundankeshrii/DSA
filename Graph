//BFS of graph
https://www.geeksforgeeks.org/problems/bfs-traversal-of-graph/1
class Solution {
    public ArrayList<Integer> bfs(ArrayList<ArrayList<Integer>> adj) {
        int V=adj.size();
        ArrayList<Integer> bfs=new ArrayList<>();
        Queue<Integer>q=new LinkedList<>();
        boolean vis[]=new boolean[V];
        q.add(0);
        vis[0]=true;
        while(!q.isEmpty()){
            Integer node=q.poll();
            bfs.add(node);
            for(int it :adj.get(node)){
                if(vis[it]==false){
                    vis[it]=true;
                    q.add(it);
                }
                
            }
        }
        return bfs;
    }
}
//DFS of graph
https://www.geeksforgeeks.org/problems/depth-first-traversal-for-a-graph/1
class Solution {
    public ArrayList<Integer> dfs(ArrayList<ArrayList<Integer>> adj) {
        int V=adj.size();
        ArrayList<Integer> ls=new ArrayList<>();
        boolean vis[]=new boolean[V];
        vis[0]=true;
        dfs(0,vis,adj,ls);
        return ls;
            }
    private void dfs(int node,boolean[] vis,ArrayList<ArrayList<Integer>> adj,ArrayList<Integer>ls){
        vis[node]=true;
        ls.add(node);
        for(int it:adj.get(node)){
            if(vis[it]==false){
                dfs(it,vis,adj,ls);
            }
        }
        
    }
}

//547. Number of Provinces
https://leetcode.com/problems/number-of-provinces/description/
class Solution {
    public int findCircleNum(int[][] isConnected) {
        int n=isConnected.length;
        boolean[] vis=new boolean[n];
        int cnt=0;
        for(int i=0;i<n;i++){
            if(vis[i]==false){
                cnt++;
                dfs(i,vis,isConnected);
            }
        }
        return cnt;
    }
    private void dfs(int i,boolean[] vis,int[][] isConnected){
        vis[i]=true;
        for(int j=0;j<isConnected.length;j++){
            if(isConnected[i][j]==1 && vis[j]==false){
                dfs(j,vis,isConnected);
            }
        }
    }
}
//Number of Islands
https://leetcode.com/problems/number-of-islands/
class Pair{
    int first;
    int second;
    public Pair(int first,int second){
        this.first=first;
        this.second=second;
    }
}
class Solution {
    public int numIslands(char[][] grid) {
        int n=grid.length;
        int m=grid[0].length;
        int[][] vis=new int[n][m];
        int cnt=0;
        int deltaRow[]={-1,0,+1,0};
        int deltaCol[]={0,+1,0,-1};
        for(int row=0;row<n;row++){
            for(int col=0;col<m;col++){
                if(vis[row][col]==0 && grid[row][col]=='1'){
                    cnt++;
                    bfs(row,col,vis,grid,deltaRow,deltaCol);
                }
            }
        }
        return cnt;
    }
    private void bfs(int row,int col,int[][] vis,char[][] grid,int deltaRow[],int deltaCol[]){
        vis[row][col]=1;
        Queue<Pair>q=new LinkedList<Pair>();
        q.add(new Pair(row,col));
        int n=grid.length;
        int m=grid[0].length;
        while(!q.isEmpty()){
             row=q.peek().first;
             col=q.peek().second;
            q.remove();

            for(int i=0;i<4;i++){
            int nrow=row+deltaRow[i];
            int ncol=col+deltaCol[i];
             if(nrow>=0 && nrow<n && ncol>=0 && ncol<m && grid[nrow][ncol]=='1' && vis[nrow][ncol]==0 ){
                        vis[nrow][ncol]=1;
                        q.add(new Pair(nrow,ncol));
                    }
                }
            }
    }
}

//733. Flood Fill
https://leetcode.com/problems/flood-fill/description/
class Solution {
    public int[][] floodFill(int[][] image, int sr, int sc, int color) {
        int[][] ans=image;
        int iniColor=image[sr][sc];
        int deltaRow[]={-1,0,+1,0};
        int deltaCol[]={0,+1,0,-1};

        dfs(sr,sc,ans,image,color,deltaRow,deltaCol,iniColor);
        return ans;
    }
    private void dfs(int row,int col,int[][]ans,int[][] image,int newColor,int deltaRow[],int deltaCol[],int iniColor){
        ans[row][col]=newColor;
        int n=image.length;
        int m=image[0].length;
        for(int i=0;i<4;i++){
            int nrow=row+deltaRow[i];
            int ncol=col+deltaCol[i];
            if(nrow>=0 && nrow<n && ncol>=0 && ncol<m && image[nrow][ncol]==iniColor && ans[nrow][ncol]!=newColor){
                dfs(nrow,ncol,ans,image,newColor,deltaRow,deltaCol,iniColor);
            }
        }
    }
}
//
class Pair{
    int row;
    int col;
    int tm;
        public Pair(int r, int c,int t){
            this.row=r;
            this.col=c;
            this.tm=t;
        }
    }
//994. Rotting Oranges
https://leetcode.com/problems/rotting-oranges/description/
class Solution {
    public int orangesRotting(int[][] grid) {
        int n=grid.length;
        int m=grid[0].length;
        int[][] vis=new int[n][m];
        Queue<Pair> q=new LinkedList<>();
        int cntFresh=0;
        for(int i=0;i<n;i++){
            for(int j=0;j<m;j++){
                if(grid[i][j]==2){
                    q.add(new Pair(i,j,0));
                    vis[i][j]=2;
                }else{
                    vis[i][j]=0;
                }
                if(grid[i][j]==1) cntFresh++;
            }
        }
        int tm=0;
        int cnt=0;
        int deltaRow[]={-1,0,+1,0};
        int deltaCol[]={0,1,0,-1};
        while(!q.isEmpty()){
            int r=q.peek().row;
            int c=q.peek().col;
            int t=q.peek().tm;
            tm=Math.max(tm,t);
            q.remove();
            for(int i=0;i<4;i++){
                int nrow=r+deltaRow[i];
                int ncol=c+deltaCol[i];
                if(nrow>=0 && nrow<n && ncol>=0 && ncol<m && vis[nrow][ncol]!=2 && grid[nrow][ncol]==1){
                    q.add(new Pair(nrow,ncol,t+1));
                    vis[nrow][ncol]=2;
                    cnt++;
                }
            }
        }
            if(cnt!=cntFresh) return -1;
            return tm;
    }
}
//Distance of nearest cell having 1
https://www.geeksforgeeks.org/problems/distance-of-nearest-cell-having-1-1587115620/1
class Pair{
    int first;
    int second;
    int third;
    public Pair(int f,int s,int t){
        this.first=f;
        this.second=s;
        this.third=t;
    }
}
class Solution {
    public ArrayList<ArrayList<Integer>> nearest(int[][] grid) {
        Queue<Pair> q=new LinkedList<>();
        int n=grid.length;
        int m=grid[0].length;
        int[][]dist=new int[n][m];
        int[][] vis=new int[n][m];
        for(int i=0;i<n;i++){
            for(int j=0;j<m;j++){
                if(grid[i][j]==1){
                    q.add(new Pair(i,j,0));
                    vis[i][j]=1;
                }else{
                    vis[i][j]=0;
                }
            }
        }
        int deltaRow[]={-1,0,1,0};
        int deltaCol[]={0,1,0,-1};
        while(!q.isEmpty()){
            int row=q.peek().first;
            int col=q.peek().second;
            int steps=q.peek().third;
            q.remove();
            dist[row][col]=steps;
            for(int i=0;i<4;i++){
                int nrow=row+deltaRow[i];
                int ncol=col+deltaCol[i];
                if(nrow>=0 && nrow<n && ncol>=0 && ncol<m && vis[nrow][ncol]==0){
                    vis[nrow][ncol]=1;
                    q.add(new Pair(nrow,ncol,steps+1));
                }
            }
        }
        ArrayList<ArrayList<Integer>> ans=new ArrayList<>();
        for(int i = 0; i < n; i++) {
            ArrayList<Integer> temp = new ArrayList<>();
            for (int j = 0; j < m; j++) {
                temp.add(dist[i][j]);   
            }
            ans.add(temp);
        }
        return ans;
    }
}
//130. Surrounded Regions
https://leetcode.com/problems/surrounded-regions/
class Solution {
    private void dfs(int row,int col,int[][] vis,char[][] board){
        vis[row][col]=1;
        int n=board.length;
        int m=board[0].length;
        int deltaRow[]={-1,0,1,0};
        int deltaCol[]={0,1,0,-1};
        for(int i=0;i<4;i++){
            int nrow=row+deltaRow[i];
            int ncol=col+deltaCol[i];
            if(nrow>=0 && nrow<n && ncol>=0 && ncol<m && vis[nrow][ncol]==0 && board[nrow][ncol]=='O'){
                dfs(nrow,ncol,vis,board);
            }
        }
    }
    public void solve(char[][] board) {
        int n=board.length;
        int m=board[0].length;
        int[][] vis=new int[n][m];
        for(int j=0;j<m;j++){
            if(vis[0][j]==0 && board[0][j]=='O'){
                dfs(0,j,vis,board);
            }
            if(vis[n-1][j]==0 && board[n-1][j]=='O'){
                dfs(n-1,j,vis,board);
            }
        }
        for(int i=0;i<n;i++){
            if(vis[i][0]==0 && board[i][0]=='O'){
                dfs(i,0,vis,board);
            }
            if(vis[i][m-1]==0 && board[i][m-1]=='O'){
                dfs(i,m-1,vis,board);
            }
        }
        for(int i=0;i<n;i++){
            for(int j=0;j<m;j++){
                if(vis[i][j]==0 && board[i][j]=='O'){
                    board[i][j]='X';
                }
            }
        }
    }
}
//1020. Number of Enclaves
https://leetcode.com/problems/number-of-enclaves/description/
class Pair{
    int first;
    int second;
    public Pair(int r, int c){
        this.first=r;
        this.second=c;
    }
}
class Solution {
    public int numEnclaves(int[][] grid) {
        int n=grid.length;
        int m=grid[0].length;
        int[][] vis=new int[n][m];
        Queue<Pair>q=new LinkedList<>();
        for(int i=0;i<n;i++){
            for(int j=0;j<m;j++){
                if(i==0||i==n-1||j==0||j==m-1){
                    if(grid[i][j]==1){
                        q.add(new Pair(i,j));
                        vis[i][j]=1;
                    }
                }
            }
        }
        int deltaRow[]={-1,0,1,0};
        int deltaCol[]={0,1,0,-1};
        while(!q.isEmpty()){
            int row=q.peek().first;
            int col=q.peek().second;
            q.remove();
            for(int i=0;i<4;i++){
                int nrow=row+deltaRow[i];
                int ncol=col+deltaCol[i];
                if(nrow>=0 && nrow<n && ncol>=0 && ncol<m && vis[nrow][ncol]==0 && grid[nrow][ncol]==1){
                    q.add(new Pair(nrow,ncol));
                    vis[nrow][ncol]=1;
                }
            }
        }
        int cnt=0;
        for(int i=0;i<n;i++){
            for(int j=0;j<m;j++){
                if(grid[i][j]==1 && vis[i][j]==0){
                    cnt++;
                }
            }
        }
        return cnt;
    }
}
//

// Number of Distinct Islands 
https://www.geeksforgeeks.org/problems/number-of-distinct-islands/1
class Solution {
    int countDistinctIslands(int[][] grid) {
        int n=grid.length;
        int m=grid[0].length;
        int[][] vis=new int[n][m];
        HashSet<ArrayList<String>>st=new HashSet<>();
        for(int i=0;i<n;i++){
            for(int j=0;j<m;j++){
                if(grid[i][j]==1 && vis[i][j]==0){
                    ArrayList<String> vec=new ArrayList<>();
                    dfs(i,j,vis,grid,vec,i,j);
                    st.add(vec);
                }
            }
        }
        return st.size();
        
    }
    private void dfs(int row,int col,int[][] vis,int[][] grid,ArrayList<String> vec,int row0,int col0){
        vis[row][col]=1;
        vec.add(toString(row-row0,col-col0));
        int n=grid.length;
        int m=grid[0].length;
        int[] deltaRow={-1,0,1,0};
        int[] deltaCol={0,1,0,-1};
        for(int i=0;i<4;i++){
            int nrow=row+deltaRow[i];
            int ncol=col+deltaCol[i];
            if(nrow>=0 && nrow<n && ncol>=0 && ncol<m && vis[nrow][ncol]==0 && grid[nrow][ncol]==1){
                dfs(nrow,ncol,vis,grid,vec,row0,col0);
            }
        }
    }
    private String toString(int r,int c){
       return   Integer.toString(r)+" "+Integer.toString(c);
    }
}
//785. Is Graph Bipartite?
https://leetcode.com/problems/is-graph-bipartite/description/
//clearly 2d adjacency matrix is given  
class Solution {
    public boolean isBipartite(int[][] graph) {
        int V=graph.length;
        int[] color=new int[V];
        for(int i=0;i<V;i++) color[i]=-1;
        for(int i=0;i<V;i++){
            if(color[i]==-1){
                if(check(i,V,graph,color)==false) return false;
            }
        }
        return true;
    }
    private boolean check(int start,int V,int[][] graph,int[] color){
        Queue<Integer>q=new LinkedList<>();
        q.add(start);
        color[start]=0;
        while(!q.isEmpty()){
            int node=q.peek();
            q.remove();
            for(int it:graph[node]){
                if(color[it]==-1){
                    color[it]=1-color[node];
                    q.add(it);
                }
                else if(color[it]==color[node]){
                    return false;
                }
            }
        }
        return true;
    }
}
//Directed Graph Cycle
https://www.geeksforgeeks.org/problems/detect-cycle-in-a-directed-graph/1
class Solution {
    public boolean isCyclic(int V, int[][] edges) {
         int vis[]=new int[V];
         int visPath[]=new int[V];
         List<List<Integer>>adj=new ArrayList<>();
        for(int i=0;i<V;i++) {
            adj.add(new ArrayList<>());
        }
        for (int[] e : edges) {
            int u = e[0];
            int v = e[1];
            adj.get(u).add(v);
        }
         for(int i=0;i<V;i++){
             if(vis[i]==0){
                 if(dfs(i,adj,vis,visPath)==true) return true;
             }
         }
         return false;
    }
    private boolean dfs(int node,List<List<Integer>>adj,int[] vis,int visPath[]){
        vis[node]=1;
        visPath[node]=1;
        for(int it:adj.get(node)){
            if(vis[it]==0){
                if(dfs(it,adj,vis,visPath)==true) return true;
            }else if(visPath[it]==1) return true;
        }
        visPath[node]=0;
        return false;
    }
}
//Detect Cycle in Directed Graph using BFS
class Solution {
    public boolean isCyclic(int V, int[][] edges) {
        ArrayList<ArrayList<Integer>>adj=new ArrayList<>();
        for(int i=0;i<V;i++){
            adj.add(new ArrayList<>());
        }
        for(int e[]:edges){
            int u=e[0];
            int v=e[1];
            adj.get(u).add(v);
        }
         int[]indegree=new int[V];
         for(int i=0;i<V;i++){
             for(int it:adj.get(i)){
               indegree[it]++;
         }
         }
         Queue<Integer>q=new LinkedList<>();
         for(int i=0;i<V;i++){
             if(indegree[i]==0){
                 q.add(i);
             }
         }
         int cnt=0;
         while(!q.isEmpty()){
             int node=q.peek();
             q.remove();
             cnt++;
             for(int it:adj.get(node)){
                 indegree[it]--;
                 if(indegree[it]==0){
                     q.add(it);
                 }
             }
             
         }
         if(cnt==V) return false;
         return true;
    }
}
//Safe States
https://www.geeksforgeeks.org/problems/eventual-safe-states/1
class Solution {
    public ArrayList<Integer> safeNodes(int V, int[][] edges) {
         int vis[]=new int[V];
         int visPath[]=new int[V];
         int check[]=new int[V];
         ArrayList<ArrayList<Integer>>adj=new ArrayList<>();
         for(int i=0;i<V;i++){
             adj.add(new ArrayList<>());
         }
         for(int[] e:edges){
             int u=e[0];
             int v=e[1];
             adj.get(u).add(v);
         }
         for(int i=0;i<V;i++){
             if(vis[i]==0){
                 dfs(i,adj,vis,visPath,check);
             }
         }
         ArrayList<Integer>ans=new ArrayList<>();
         for(int i=0;i<V;i++){
             if(check[i]==1) ans.add(i);
         }
         return ans;
        
    }
    private boolean dfs(int node,ArrayList<ArrayList<Integer>>adj,int[] vis,int[]visPath,int[]check){
        vis[node]=1;
        visPath[node]=1;
        check[node]=0;
        for(int it : adj.get(node)){
            if(vis[it]==0){
                if(dfs(it,adj,vis,visPath,check)==true){
                return true;
                }
            }
            else if(visPath[it]==1) return true;
        
    }
    check[node]=1;
    visPath[node]=0;
    return false;

}
}
//802. Find Eventual Safe States
https://leetcode.com/problems/find-eventual-safe-states/description/
class Solution {
    public List<Integer> eventualSafeNodes(int[][] graph) {
        int V=graph.length;
        int[]indegree=new int[V];
        ArrayList<ArrayList<Integer>>adjRev=new ArrayList<>();
        for(int i=0;i<V;i++){
            adjRev.add(new ArrayList<>());
        }
        for(int i=0;i<V;i++){
            for(int it:graph[i]){
                adjRev.get(it).add(i);
                indegree[i]++;
            }
        } 
        Queue<Integer>q=new LinkedList<>();
        for(int i=0;i<V;i++){
            if(indegree[i]==0){
                q.add(i);
            }
        }
        List<Integer>topo=new ArrayList<>();
        while(!q.isEmpty()){
            int node=q.peek();
            q.remove();
            topo.add(node);
            for(int it:adjRev.get(node)){
                indegree[it]--;
                if(indegree[it]==0){
                    q.add(it);
                }
            }
        }
        Collections.sort(topo);
        return topo;
    }
}
//Topological Sort
https://www.geeksforgeeks.org/problems/topological-sort/1
class Solution {
    public ArrayList<Integer> topoSort(int V, int[][] edges) {
        ArrayList<ArrayList<Integer>>adj=new ArrayList<>();
        for(int i=0;i<V;i++){
            adj.add(new ArrayList<>());
        }
        for(int e[]:edges){
            int u=e[0];
            int v=e[1];
            adj.get(u).add(v);
        }
         int[]vis=new int[V];
         Stack<Integer>st=new Stack<>();
         for(int i=0;i<V;i++){
             if(vis[i]==0){
                 dfs(i,vis,adj,st);
             }
         }
         ArrayList<Integer>ans=new ArrayList<>();
         while(!st.isEmpty()){
             ans.add(st.peek());
             st.pop();
         }
         return ans;
    }
    private void dfs(int node,int[]vis, ArrayList<ArrayList<Integer>>adj,Stack<Integer>st){
        vis[node]=1;
        for(int it:adj.get(node)){
            if(vis[it]==0){
                dfs(it,vis,adj,st);
                
            }
        }
            st.push(node);
    }
}
//Topological sorting (Kahn's Algorithm) using BFS
class Solution {
    public ArrayList<Integer> topoSort(int V, int[][] edges) {
        ArrayList<ArrayList<Integer>>adj=new ArrayList<>();
        for(int i=0;i<V;i++){
            adj.add(new ArrayList<>());
        }
        for(int e[]:edges){
            int u=e[0];
            int v=e[1];
            adj.get(u).add(v);
        }
         int[]indegree=new int[V];
         for(int i=0;i<V;i++){
             for(int it:adj.get(i)){
               indegree[it]++;
         }
         }
         Queue<Integer>q=new LinkedList<>();
         for(int i=0;i<V;i++){
             if(indegree[i]==0){
                 q.add(i);
             }
         }
         ArrayList<Integer>topo=new ArrayList<>();
         while(!q.isEmpty()){
             int node=q.peek();
             q.remove();
             topo.add(node);
             for(int it:adj.get(node)){
                 indegree[it]--;
                 if(indegree[it]==0){
                     q.add(it);
                 }
             }
             
         }
         return topo;
    }
}
//207. Course Schedule-I
https://leetcode.com/problems/course-schedule/description/
class Solution {
    public boolean canFinish(int numCourses, int[][] prerequisites) {
         ArrayList<ArrayList<Integer>>adj=new ArrayList<>();
         for(int i=0;i<numCourses;i++){
            adj.add(new ArrayList<>());
         }
         for(int[]e:prerequisites){
            int u=e[0];
            int v=e[1];
             adj.get(u).add(v);
            }
        int indegree[]=new int[numCourses];
        for(int i=0;i<numCourses;i++){
            for(int it:adj.get(i)){
                    indegree[it]++;
            }
        }
        Queue<Integer>q=new LinkedList<>();
        for(int i=0;i<numCourses;i++){
            if(indegree[i]==0){
                    q.add(i);
            }
        }
        List<Integer>topo=new ArrayList<>();
        while(!q.isEmpty()){
                int node =q.peek();
                q.remove();
                topo.add(node);
            for(int it:adj.get(node)){
                    indegree[it]--;
                    if(indegree[it]==0){
                        q.add(it);
                    }
                }
            }
                if(topo.size()==numCourses) return true;
                return false;
    }
}
210. Course Schedule II
https://leetcode.com/problems/course-schedule-ii/
class Solution {
    public int[] findOrder(int numCourses, int[][] prerequisites) {
         ArrayList<ArrayList<Integer>>adj=new ArrayList<>();
         for(int i=0;i<numCourses;i++){
            adj.add(new ArrayList<>());
         }
         for(int[]e:prerequisites){
            int u=e[1];
            int v=e[0];
             adj.get(u).add(v);
            }
        int indegree[]=new int[numCourses];
        for(int i=0;i<numCourses;i++){
            for(int it:adj.get(i)){
                    indegree[it]++;
            }
        }
        Queue<Integer>q=new LinkedList<>();
        for(int i=0;i<numCourses;i++){
            if(indegree[i]==0){
                    q.add(i);
            }
        }
        int[] topo=new int[numCourses];
        int i=0;
        while(!q.isEmpty()){
                int node =q.peek();
                q.remove();
                topo[i]=node;
                i++;
            for(int it:adj.get(node)){
                    indegree[it]--;
                    if(indegree[it]==0){
                        q.add(it);
                    }
                }
            }
                if(i==numCourses) return topo;//we compare with i because it gives actual size of the filled arr, where as if you wish that to compare with V then it will always equal because you have created with the same size and you know arr is not dynamic in size ;
                return new int[]{} ;
    }
}
//Alien dictionary
 https://leetcode.com/problems/alien-dictionary/
class Solution {
    public String findOrder(String[] words, int N, int K) {
        List<List<Integer>> adj = new ArrayList<>();
        for(int i = 0; i < K; i++){
            adj.add(new ArrayList<>());
        }

        for(int i = 0; i < N - 1; i++){
            String str1 = words[i];
            String str2 = words[i + 1];

            int len = Math.min(str1.length(), str2.length());
            for(int ptr = 0; ptr < len; ptr++){
                if(str1.charAt(ptr) != str2.charAt(ptr)){
                    adj.get(str1.charAt(ptr) - 'a').add(str2.charAt(ptr) - 'a');
                    break;
                }
            }
        }
        List<Integer> topo = topoSort(K, adj);
        if(topo.size() < K) return "";
        StringBuilder ans = new StringBuilder();
        for(int ch : topo){
            ans.append((char)(ch + 'a'));
        }
        return ans.toString();
    }
    private List<Integer> topoSort(int K, List<List<Integer>> adj){
        int[] indegree = new int[K];
        for(int i = 0; i < K; i++){
            for(int it : adj.get(i)){
                indegree[it]++;
            }
        }
        Queue<Integer> q = new LinkedList<>();
        for(int i = 0; i < K; i++){
            if(indegree[i] == 0){
                q.add(i);
            }
        }
        List<Integer> ans = new ArrayList<>();
        while(!q.isEmpty()){
            int node = q.poll();
            ans.add(node);

            for(int it : adj.get(node)){
                indegree[it]--;
                if(indegree[it] == 0){
                    q.add(it);
                }
            }
        }
        return ans;
    }
}

//Shortest path in Directed Acyclic Graph
https://www.geeksforgeeks.org/problems/shortest-path-in-undirected-graph/1
class Pair{
    int first;
    int second;
    public Pair(int v,int wt){
        this.first=v;
        this.second=wt;
    }
}
class Solution {
    public int[] shortestPath(int V, int E, int[][] edges) {
        ArrayList<ArrayList<Pair>>adj=new ArrayList<>();
        for(int i=0;i<V;i++){
            adj.add(new ArrayList<Pair>());
        }
        for(int i=0;i<E;i++){
            int u=edges[i][0];
            int v=edges[i][1];
            int wt=edges[i][2];
            adj.get(u).add(new Pair(v,wt));
        }
        int vis[]=new int[V];
        Stack<Integer>st=new Stack<>();
        for(int i=0;i<V;i++){
            if(vis[i]==0){
                topoSort(i,adj,vis,st);
            }
        }
        int dis[]=new int[V];
        for(int i=0;i<V;i++) {
            dis[i]=Integer.MAX_VALUE;
        }
        dis[0]=0;
        while(!st.isEmpty()){
            int node=st.peek();
            st.pop();
            if(dis[node] != Integer.MAX_VALUE) {
                for(int i=0;i<adj.get(node).size();i++){
                    int v = adj.get(node).get(i).first;
                    int wt = adj.get(node).get(i).second;
                    if(dis[node] + wt < dis[v]){
                        dis[v] = dis[node] + wt;
                    }
                }

            }
        }
        for(int i=0;i<V;i++){
            if(dis[i]==Integer.MAX_VALUE) dis[i]=-1;
        }
            return dis;
    }
        private void topoSort(int node, ArrayList<ArrayList<Pair>>adj,int vis[],Stack<Integer>st){
            vis[node]=1;
            for(int i=0;i<adj.get(node).size();i++){
                int v=adj.get(node).get(i).first;
                if(vis[v]==0){
                    topoSort(v,adj,vis,st);
                }
            }
            st.push(node);
        }
}
//Shortest Path in Undirected Graph
https://www.geeksforgeeks.org/problems/shortest-path-in-undirected-graph-having-unit-distance/1
class Solution {
    public int[] shortestPath(int V, int[][] edges, int src) {
        int m=edges.length;
         ArrayList<ArrayList<Integer>>adj=new ArrayList<>();
         for(int i=0;i<V;i++){
             adj.add(new ArrayList<>());
         }
         for(int i=0;i<m;i++){
             adj.get(edges[i][0]).add(edges[i][1]);
             adj.get(edges[i][1]).add(edges[i][0]);
         }
         int dist[]=new int[V];
         Arrays.fill(dist, -1);
         dist[src]=0;
         Queue<Integer>q=new LinkedList<>();
         q.add(src);
         while(!q.isEmpty()){
             int node=q.peek();
             q.remove();
             for(int it:adj.get(node)){
                 if(dist[it]==-1){
                     dist[it]=1+dist[node];
                     q.add(it);
                 }
             }
         }
         return dist;
    }
}
//Word Ladder-I
https://leetcode.com/problems/word-ladder/
class Pair{
    String first;
    int second;
    public Pair(String str,int steps){
        this.first=str;
        this.second=steps;
    }
}
class Solution {
    public int ladderLength(String beginWord, String endWord, List<String> wordList) {
        Queue<Pair>q=new LinkedList<>();
        q.add(new Pair(beginWord,1));
        Set<String>st=new HashSet<String>();
        int len=wordList.size();
        for(int i=0;i<len;i++){
            st.add(wordList.get(i));
        }
        st.remove(beginWord);
        while(!q.isEmpty()){
            String word=q.peek().first;
            int steps=q.peek().second;
            q.remove();
            if(word.equals(endWord)==true) return steps;
            for(int i=0;i<word.length();i++){
                //h
                for(char ch='a';ch<='z';ch++){
                    //aat
                    //bat
                    //cat
                    char replacedCharArray[]=word.toCharArray();
                    replacedCharArray[i]=ch;
                    String replacedWord=new String(replacedCharArray);
                    if(st.contains(replacedWord)==true) {
                        st.remove(replacedWord);
                        q.add(new Pair(replacedWord,steps+1));
                    }
                }
            }
        }
        return 0;
    }
}
//Word Ladder-II
https://leetcode.com/problems/word-ladder-ii/
//with TLE
class Solution {
    public List<List<String>> findLadders(String beginWord, String endWord, List<String> wordList) {
        Set<String>st=new HashSet<>();
        int len=wordList.size();
        for(int i=0;i<len;i++) st.add(wordList.get(i));
        ArrayList<String>ls=new ArrayList<>();
        ls.add(beginWord);
        Queue<ArrayList<String>>q=new LinkedList<>();
        q.add(ls);
        ArrayList<String> usedOnLevel=new ArrayList<>();
        usedOnLevel.add(beginWord);
        List<List<String>>ans=new ArrayList<>();
        int level=0;
        while(!q.isEmpty()){
            List<String>vec=q.peek();
            q.remove();
            if(vec.size()>level){
                level++;
                for(String it: usedOnLevel){
                    st.remove(it);
                }
            }
            String word=vec.get(vec.size()-1);
            if(word.equals(endWord)==true){
                ans.add(vec);
            }
            for(int i=0;i<word.length();i++){
                for(char ch='a';ch<='z';ch++){
                    char replacedCharArray[]=word.toCharArray();
                    replacedCharArray[i]=ch;
                    String replacedWord=new String(replacedCharArray);
                    if(st.contains(replacedWord)==true){
                        vec.add(replacedWord);
                        ArrayList<String>temp=new ArrayList<>(vec);
                        q.add(temp);
                        usedOnLevel.add(replacedWord);
                        vec.remove(vec.size()-1);
                    }
                }
            }
        }
        return ans;
    }
}
//Optimal Solution using CP approach
class Solution {
    String b;
    HashMap<String,Integer> mpp;
    List<List<String>>ans;
    public List<List<String>> findLadders(String beginWord, String endWord, List<String> wordList) {
        Set<String>st=new HashSet<>();
        int len=wordList.size();
        for(int i=0;i<len;i++) st.add(wordList.get(i));
        Queue<String>q=new LinkedList<>();
        q.add(beginWord);
        b=beginWord;
        mpp=new HashMap<>();
        mpp.put(beginWord,1);
        st.remove(beginWord);
        while(!q.isEmpty()){
            String word=q.peek();
            int steps=mpp.get(word);
            q.remove();
            if(word.equals(endWord)==true) break;
            for(int i=0;i<word.length();i++){
                for(char ch='a';ch<='z';ch++){
                    char replacedCharArray[]=word.toCharArray();
                    replacedCharArray[i]=ch;
                    String replacedWord=new String(replacedCharArray);
                    if(st.contains(replacedWord)==true){
                        q.add(replacedWord);
                        st.remove(replacedWord);
                        mpp.put(replacedWord,steps+1);
                    }
                }
            }
        }
        ans=new ArrayList<>();
        if(mpp.containsKey(endWord)==true){
            List<String> seq=new ArrayList<>();
            seq.add(endWord);
            dfs(endWord,seq);
        }
        return ans;
    }
    private void dfs(String word,List<String> seq){
        if(word.equals(b)==true){
            List<String>dup=new ArrayList<>(seq);
            Collections.reverse(dup);
            ans.add(dup);
            return;
        }
        int steps=mpp.get(word);
        for(int i=0;i<word.length();i++){
            for(char ch='a';ch<='z';ch++){
                char replacedCharArray[]=word.toCharArray();
                replacedCharArray[i]=ch;
                String replacedWord=new String(replacedCharArray);
                if(mpp.containsKey(replacedWord) && mpp.get(replacedWord)+1==steps){
                    seq.add(replacedWord);
                    dfs(replacedWord,seq);
                    seq.remove(seq.size()-1);
                }
            }
        }
    }
}
//Dijkstra's Algo. using PriorityQueue
 https://www.geeksforgeeks.org/problems/implementing-dijkstra-set-1-adjacency-matrix/1
class Solution {
    class Pair{
    int distance;
    int node;
    public Pair(int distance,int node){
        this.distance=distance;
        this.node=node;
    }
}
    public int[] dijkstra(int V, int[][] edges, int src) {
        ArrayList<ArrayList<int[]>>adj=new ArrayList<>();
        for(int i=0;i<V;i++) adj.add(new ArrayList<>());
        for(int[] e:edges){
            int u=e[0];
            int v=e[1];
            int w=e[2];
            adj.get(u).add(new int[]{v,w});
            adj.get(v).add(new int[]{u,w});
        }
        int dist[]=new int[V];
        Arrays.fill(dist,Integer.MAX_VALUE);
        dist[src]=0;
        PriorityQueue<Pair>pq=new PriorityQueue<Pair>((x,y)-> x.distance-y.distance);
        pq.add(new Pair(0,src));
        while(pq.size()!=0){
            int top=pq.peek().distance;
            int node=pq.peek().node;
            pq.remove();
            for(int[] it:adj.get(node)){
                int adjNode=it[0];
                int edgeWeight=it[1];
                if(top + edgeWeight<dist[adjNode]){
                    dist[adjNode]=top+edgeWeight;
                    pq.add(new Pair(dist[adjNode],adjNode));
                }
            }
        }
        return dist;
        
    }
}
//Shortest Path in Weighted undirected graph
https://www.geeksforgeeks.org/problems/shortest-path-in-weighted-undirected-graph/1
class Solution {
    class Pair{
    int first;
    int second;
    public Pair(int first,int second){
        this.first=first;
        this.second=second;
    }
    }
    public List<Integer> shortestPath(int n, int m, int edges[][]) {
          ArrayList<ArrayList<Pair>>adj=new ArrayList<>();
        for(int i=0;i<=n;i++) adj.add(new ArrayList<>());
        for(int[] e:edges){
            int u=e[0];
            int v=e[1];
            int w=e[2];
            adj.get(u).add(new Pair(v,w));
            adj.get(v).add(new Pair(u,w));
        }
        int dist[]=new int[n+1];
        int parent[]=new int[n+1];
        for(int i=1;i<=n;i++){
            dist[i]=Integer.MAX_VALUE;
            parent[i]=i;
        }
        dist[1]=0;
        PriorityQueue<Pair>pq=new PriorityQueue<Pair>((x,y)-> x.first-y.first);
        pq.add(new Pair(0,1));
        while(pq.size()!=0){
            int top=pq.peek().first;
            int node=pq.peek().second;
            pq.remove();
            for(Pair it:adj.get(node)){
                int adjNode=it.first;
                int edgeWeight=it.second;
                if(top + edgeWeight<dist[adjNode]){
                    dist[adjNode]=top+edgeWeight;
                    pq.add(new Pair(dist[adjNode],adjNode));
                    parent[adjNode]=node;
                }
            }
        }
        List<Integer>path=new ArrayList<>();
        if(dist[n]==Integer.MAX_VALUE){
            path.add(-1);
            return path;
        }
        int node=n;
        while(parent[node]!=node){
            path.add(node);
            node=parent[node];
        }
        path.add(1);
        Collections.reverse(path);
        path.add(0,dist[n]);
        return path;
        
    }
}
