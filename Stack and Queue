//https://www.geeksforgeeks.org/problems/sort-a-stack/1
class Solution {
     public void sortStack(Stack<Integer>st){
        if(st.isEmpty()) return;
        int element=st.pop();
        sortStack(st);
        insertRight(st,element);
    }
    private void insertRight(Stack<Integer> st,int element){
        if(st.isEmpty() || element>=st.peek()){
            st.push(element);
            return;
        }
            int top=st.pop();
            insertRight(st, element);
            st.push(top);
        }
}

https://leetcode.com/problems/implement-stack-using-queues/description/
//225. Implement Stack using Queues
class MyStack {
          Queue < Integer > queue ;
    public MyStack() {
           queue = new LinkedList < > ();
        }    
    public void push(int x) {
          queue.add(x);
        for (int i = 0; i < queue.size() - 1; i++) {
            queue.add(queue.remove());
    }
    
    }
    public int pop() {
        return queue.remove();
    }
    
    public int top() {
        return queue.peek();
    }
    
    public boolean empty() {
       return queue.isEmpty();
    }
}

//Next Greater Element -I
https://leetcode.com/problems/next-greater-element-i/description/
class Solution {
    public int[] nextGreaterElement(int[] nums1, int[] nums2) {
        int n = nums2.length;
        int[] next = new int[n];
        Stack<Integer> st = new Stack<>();
        
        for (int i = n - 1; i >= 0; i--) {
            while (!st.isEmpty() && st.peek() <= nums2[i]) {
                st.pop();
            }
            next[i] = st.isEmpty() ? -1 : st.peek();
            st.push(nums2[i]);
        }
        
        int[] result = new int[nums1.length];
        for (int i = 0; i < nums1.length; i++) {
            for (int j = 0; j < n; j++) {
                if (nums2[j] == nums1[i]) {
                    result[i] = next[j];
                    break;
                }
            }
        }
        
        return result;
    }
}
//Next Greater Element-II
https://leetcode.com/problems/next-greater-element-ii/
class Solution {
    public int[] nextGreaterElements(int[] nums) {
        int[] nge=new int[nums.length];
        Stack<Integer>st=new Stack<>();
        int N=nums.length;
        for(int i=2*N-1;i>=0;i--){
            while(!st.isEmpty() && st.peek()<=nums[i%N]){
                st.pop();
            }
            if(i<N){
                nge[i]=st.isEmpty() ? -1:st.peek();
            }
            st.push(nums[i%N]);
        }
        return nge;
    }
}
//402. Remove K Digits
https://leetcode.com/problems/remove-k-digits/description/

    class Solution {
    public String removeKdigits(String nums, int k) {
        Stack<Character> st=new Stack<>();
        for(int i=0;i<nums.length();i++){
            char digit=nums.charAt(i);
            while(!st.isEmpty() && k>0 && st.peek() > digit ){
                st.pop();
                k--;
            }
            st.push(digit);
        }
        if(st.isEmpty()) return "0";
        while(k>0) {
            st.pop();
             k--;
        }
    StringBuilder res=new StringBuilder();
            while(!st.isEmpty()){
                res.append(st.pop());
            }
            res.reverse();
            while(res.length()>0 && res.charAt(0)=='0'){
                res.deleteCharAt(0);
            }
            if(res.length()==0) return "0";
            return res.toString();

    }
}
//20. Valid Parentheses
https://leetcode.com/problems/valid-parentheses/description/
import java.util.Stack;

class Solution {
    public boolean isValid(String s) {
        Stack<Character> st = new Stack<>();
        
        for (char c : s.toCharArray()) {
            if (c == '(' || c == '{' || c == '[') {
                st.push(c);
            } else {
                if (st.isEmpty()) return false;
                
                char top = st.pop();
                if (c == ')' && top != '(') return false;
                if (c == '}' && top != '{') return false;
                if (c == ']' && top != '[') return false;
            }
        }
        
        return st.isEmpty();
    }
}
//2104. Sum of Subarray Ranges
https://leetcode.com/problems/sum-of-subarray-ranges/description/
class Solution {
    public long subArrayRanges(int[] nums) {
        int n = nums.length;
        long sum = 0;
        for (int i=0;i<n;i++) {
            int smallest = nums[i];
            int largest = nums[i];
            for (int j=i;j<n;j++) {
                smallest = Math.min(smallest, nums[j]);
                largest = Math.max(largest, nums[j]);
                sum += (largest - smallest);
            }
        }

        return sum;
    }
}

//907. Sum of Subarray Minimums
//it gives Time Limit Exceeded
class Solution {
    public int sumSubarrayMins(int[] arr) {
        int n = arr.length;
        long sum = 0;
        int mod = (int)1e9 + 7;
        
        for (int i = 0; i < n; i++) {
            int minimum = arr[i];
            for (int j = i; j < n; j++) {
                minimum = Math.min(minimum, arr[j]);
                sum = (sum + minimum) % mod;
            }
        }
        return (int)sum;
    }
}

