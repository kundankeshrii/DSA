//https://www.geeksforgeeks.org/problems/sort-a-stack/1
class Solution {
     public void sortStack(Stack<Integer>st){
        if(st.isEmpty()) return;
        int element=st.pop();
        sortStack(st);
        insertRight(st,element);
    }
    private void insertRight(Stack<Integer> st,int element){
        if(st.isEmpty() || element>=st.peek()){
            st.push(element);
            return;
        }
            int top=st.pop();
            insertRight(st, element);
            st.push(top);
        }
}

https://leetcode.com/problems/implement-stack-using-queues/description/
//225. Implement Stack using Queues
class MyStack {
          Queue < Integer > queue ;
    public MyStack() {
           queue = new LinkedList < > ();
        }    
    public void push(int x) {
          queue.add(x);
        for (int i = 0; i < queue.size() - 1; i++) {
            queue.add(queue.remove());
    }
    
    }
    public int pop() {
        return queue.remove();
    }
    
    public int top() {
        return queue.peek();
    }
    
    public boolean empty() {
       return queue.isEmpty();
    }
}

//Next Greater Element -I
https://leetcode.com/problems/next-greater-element-i/description/
class Solution {
    public int[] nextGreaterElement(int[] nums1, int[] nums2) {
        int n = nums2.length;
        int[] next = new int[n];
        Stack<Integer> st = new Stack<>();
        
        for (int i = n - 1; i >= 0; i--) {
            while (!st.isEmpty() && st.peek() <= nums2[i]) {
                st.pop();
            }
            next[i] = st.isEmpty() ? -1 : st.peek();
            st.push(nums2[i]);
        }
        
        int[] result = new int[nums1.length];
        for (int i = 0; i < nums1.length; i++) {
            for (int j = 0; j < n; j++) {
                if (nums2[j] == nums1[i]) {
                    result[i] = next[j];
                    break;
                }
            }
        }
        
        return result;
    }
}
//Next Greater Element-II
https://leetcode.com/problems/next-greater-element-ii/
class Solution {
    public int[] nextGreaterElements(int[] nums) {
        int[] nge=new int[nums.length];
        Stack<Integer>st=new Stack<>();
        int N=nums.length;
        for(int i=2*N-1;i>=0;i--){
            while(!st.isEmpty() && st.peek()<=nums[i%N]){
                st.pop();
            }
            if(i<N){
                nge[i]=st.isEmpty() ? -1:st.peek();
            }
            st.push(nums[i%N]);
        }
        return nge;
    }
}
//402. Remove K Digits
https://leetcode.com/problems/remove-k-digits/description/

    class Solution {
    public String removeKdigits(String nums, int k) {
        Stack<Character> st=new Stack<>();
        for(int i=0;i<nums.length();i++){
            char digit=nums.charAt(i);
            while(!st.isEmpty() && k>0 && st.peek() > digit ){
                st.pop();
                k--;
            }
            st.push(digit);
        }
        if(st.isEmpty()) return "0";
        while(k>0) {
            st.pop();
             k--;
        }
    StringBuilder res=new StringBuilder();
            while(!st.isEmpty()){
                res.append(st.pop());
            }
            res.reverse();
            while(res.length()>0 && res.charAt(0)=='0'){
                res.deleteCharAt(0);
            }
            if(res.length()==0) return "0";
            return res.toString();

    }
}
//20. Valid Parentheses
https://leetcode.com/problems/valid-parentheses/description/
import java.util.Stack;

class Solution {
    public boolean isValid(String s) {
        Stack<Character> st = new Stack<>();
        
        for (char c : s.toCharArray()) {
            if (c == '(' || c == '{' || c == '[') {
                st.push(c);
            } else {
                if (st.isEmpty()) return false;
                
                char top = st.pop();
                if (c == ')' && top != '(') return false;
                if (c == '}' && top != '{') return false;
                if (c == ']' && top != '[') return false;
            }
        }
        
        return st.isEmpty();
    }
}
//2104. Sum of Subarray Ranges
https://leetcode.com/problems/sum-of-subarray-ranges/description/
class Solution {
    public long subArrayRanges(int[] nums) {
        int n = nums.length;
        long sum = 0;
        for (int i=0;i<n;i++) {
            int smallest = nums[i];
            int largest = nums[i];
            for (int j=i;j<n;j++) {
                smallest = Math.min(smallest, nums[j]);
                largest = Math.max(largest, nums[j]);
                sum += (largest - smallest);
            }
        }

        return sum;
    }
}
//M-2
class Solution {
    public long subArrayRanges(int[] nums) {
        return SOSMax(nums)-SOSMin(nums);
    }
    private long SOSMin(int[] arr){
        int n=arr.length;
        long total=0;
        int[] nse=findNSE(arr);
        int[] psee=findPSEE(arr);
        for(int i=0;i<n;i++){
            long left=i-psee[i];
            long right=nse[i]-i;
            total=total+(left*right*1L*arr[i]);
        }
        return total;
    }
    private int[] findNSE(int[] arr){
        int n=arr.length;
        Stack<Integer> st=new Stack<>();
        int[] NSE=new int[n];
        for(int i=n-1;i>=0;i--){
            while(!st.isEmpty() && arr[st.peek()]>=arr[i]){
                st.pop();
            }
            NSE[i]=!st.isEmpty() ? st.peek() : n;
            st.push(i);
        }
        return NSE;
    }
    private int[] findPSEE(int[] arr){
        int n=arr.length;
        int[] PSEE=new int[n];
        Stack<Integer>st=new Stack<>();
        for(int i=0;i<n;i++){
            while(!st.isEmpty() && arr[st.peek()]> arr[i]){
                st.pop();
            }
            PSEE[i]=!st.isEmpty()? st.peek():-1;
            st.push(i);
        }
        return PSEE;
    }
    private long SOSMax(int[] arr){
        long total=0;
        int n=arr.length;
        int[] nge=findNGE(arr);
        int[] pgee=findPGEE(arr);
        for(int i=0;i<n;i++){
            long left=i-pgee[i];
            long right=nge[i]-i;
            total=total+(left*right*1L*arr[i]);

        }
        return total;
    }
    private int[] findNGE(int[] arr){
        int n=arr.length;
        Stack<Integer> st=new Stack<>();
        int[] NGE=new int[n];
        for(int i=n-1;i>=0;i--){
            while(!st.isEmpty() && arr[st.peek()]<=arr[i]){
                st.pop();
            }
            NGE[i]=!st.isEmpty() ? st.peek() : n;
            st.push(i);
        }
        return NGE;
    }
    private int[] findPGEE(int[] arr){
        int n=arr.length;
        int[] PGEE=new int[n];
        Stack<Integer>st=new Stack<>();
        for(int i=0;i<n;i++){
            while(!st.isEmpty() && arr[st.peek()]< arr[i]){
                st.pop();
            }
            PGEE[i]=!st.isEmpty()? st.peek():-1;
            st.push(i);
        }
        return PGEE;
    }
}

//907. Sum of Subarray Minimums
//it gives Time Limit Exceeded
class Solution {
    public int sumSubarrayMins(int[] arr) {
        int n = arr.length;
        long sum = 0;
        int mod = (int)1e9 + 7;
        
        for (int i = 0; i < n; i++) {
            int minimum = arr[i];
            for (int j = i; j < n; j++) {
                minimum = Math.min(minimum, arr[j]);
                sum = (sum + minimum) % mod;
            }
        }
        return (int)sum;
    }
}
//M-2
class Solution {
    public int sumSubarrayMins(int[] arr) {
        int n = arr.length;
        long total = 0;
        int mod = (int)1e9 + 7;
        int[] nse=findNSE(arr);
        int[] psee=findPSEE(arr);
       for(int i=0;i<arr.length;i++){
        long left= i-psee[i];
        long right= nse[i]-i;
        long freq=right*left*1L;
        long val=(int)((freq*arr[i])%mod);
        total=(total +val)%mod;

       }
       return (int)total;
    }
    private int[] findNSE(int[] arr){
        int n=arr.length;
        int[] nse=new int[n];
        Stack<Integer> st=new Stack<>();
        for(int i=n-1;i>=0;i--){
            while(!st.isEmpty() && arr[st.peek()]>=arr[i]){
                st.pop();
            }
                nse[i]=!st.isEmpty() ? st.peek() : n;
                st.push(i);
        }
        return nse;
    }
    private int[] findPSEE(int[] arr){
        int[] psee=new int[arr.length];
        Stack<Integer> st=new Stack<>();
        for(int i=0;i<arr.length;i++){
            while(!st.isEmpty() && arr[st.peek()]>arr[i]){
                st.pop();
            }
                psee[i]=!st.isEmpty() ? st.peek():-1;
                st.push(i);
        }
        return psee;
    }
}


//503. Next Greater Element II
//M-1
class Solution {
    public int[] nextGreaterElements(int[] nums) {
        int[] nge=new int[nums.length];
        Stack<Integer>st=new Stack<>();
        int N=nums.length;
        for(int i=2*N-1;i>=0;i--){
            while(!st.isEmpty() && st.peek()<=nums[i%N]){
                st.pop();
            }
            if(i<N){
                nge[i]=st.isEmpty() ? -1:st.peek();
            }
            st.push(nums[i%N]);
        }
        return nge;
    }
}
//M-2
class Solution {
    public int[] nextGreaterElements(int[] nums) {
        int[] nge=new int[nums.length];
        int N=nums.length;
        for(int i=0;i<nums.length;i++){
            nge[i]=-1;
        }
        for(int i=0;i<N;i++){
            for(int j=i+1;j<i+N;j++){
                int index=j%N;
                if(nums[index]>nums[i]){
                    nge[i]=nums[index];
                    break;
                }
            }

            }
            return nge;
    }
}

//735. Asteroid Collision
https://leetcode.com/problems/asteroid-collision/description/
class Solution {
    public int[] asteroidCollision(int[] asteroids) {
        List<Integer>st=new ArrayList<>();
        for(int i=0;i<asteroids.length;i++){
            if(asteroids[i]>0){
                st.add(asteroids[i]);
            }else{
                    while(!st.isEmpty() && st.get(st.size()-1)>0 && st.get(st.size()-1)<Math.abs(asteroids[i])) {
                        st.remove(st.size()-1);
                    }
                    if(!st.isEmpty() && st.get(st.size()-1) == Math.abs(asteroids[i])){
                        st.remove(st.size()-1);
                    }
                    else if(st.isEmpty() || st.get(st.size()-1)<0){
                        st.add(asteroids[i]);
                    }
                }
            }
            int[] arr=new int[st.size()];
            for(int i=0;i<arr.length;i++){
                arr[i]=st.get(i);
            }
            return arr;
        
    }
}
//84. Largest Rectangle in Histogram
https://leetcode.com/problems/largest-rectangle-in-histogram/description/
class Solution {
public int largestRectangleArea(int[] heights) {
Stack<Integer> stack=new Stack<>();
int max=0;
stack.push(0);
        for (int i = 1; i < heights.length ; i++) {
            while(!stack.isEmpty() &&heights[i]<heights[stack.peek()]){
                max=getMax(heights,stack,max,i);
            }
            stack.push(i);

        }
        int i=heights.length;
        while(!stack.isEmpty()){
            max=getMax(heights,stack,max,i);
        }
        return max;
    }

    private int getMax(int[] arr, Stack<Integer> stack, int max, int i) {
        int popped=stack.pop();
        int width;
        if(stack.isEmpty()){
            width=i;
        }else{
       width=i-stack.peek()-1;
        }
        int area=arr[popped]*width;
        return Math.max(max,area);
            
    }
}

//85. Maximal Rectangle
https://leetcode.com/problems/maximal-rectangle/
class Solution {
    public int maximalRectangle(char[][] matrix) {
        int n=matrix.length;
        int m=matrix[0].length;
        int[][] pSum=new int[n][m];
        for(int j=0;j<m;j++){
            int sum=0;
            for(int i=0;i<n;i++){
                if(matrix[i][j]=='0') {
                    pSum[i][j]=0;
                    sum=0;
                }else{
                    sum++;
                pSum[i][j]=sum;
              }
            }
        }
            int maxArea=0;
            for(int i=0;i<n;i++){
                int area=lHistogram(pSum[i]);
                maxArea=Math.max(maxArea, area);
            }
            return maxArea;
    }
    private int lHistogram(int[] arr){
        Stack<Integer> st=new Stack<>();
        int nse;
        int pse;
        int maxArea=0;
        for(int i=0;i<arr.length;i++){
            while(!st.isEmpty() && arr[st.peek()]>= arr[i]){
                int element=st.peek();
                st.pop();
                 nse=i;
                 pse=st.isEmpty() ? -1: st.peek();
                maxArea=Math.max(maxArea,(nse-pse-1)*arr[element]);
            }
            st.push(i);
        }
        while(!st.isEmpty()){
             nse=arr.length;
        int element=st.peek();
        st.pop();
         pse=st.isEmpty()? -1 : st.peek();
        maxArea=Math.max(maxArea,(nse-pse-1)*arr[element]);
        }
        return maxArea;
    }
}
//901. Online Stock Span
https://leetcode.com/problems/online-stock-span/description/
class StockSpanner {
        List<Integer> list=new ArrayList<>();
    public StockSpanner() {
        list=new ArrayList<>();
    }
    
    public int next(int price) {
        list.add(price);
        int cnt=1;
        for(int i=list.size()-2;i>=0;i--){
            if(list.get(i)<=price){
                cnt++;
            }else{
                 break;
            }
        }
        return cnt;
    }
}

//239. Sliding Window Maximum
https://leetcode.com/problems/sliding-window-maximum/description/
//Brute force solution
//it gives time limit exceeds
class Solution {
    public int[] maxSlidingWindow(int[] nums, int k) {
        List<Integer>list=new ArrayList<>();
        for(int i=0;i<=nums.length-k;i++){
            int maxi=nums[i];
            for(int j=i;j<i+k;j++){
                maxi=Math.max(maxi,nums[j]);
            }
                list.add(maxi);

        }
        int [] arr=new int[list.size()];
        for(int i=0;i<list.size();i++){
            arr[i]=list.get(i);
        }
        return arr;
    }
}
//Method 2 using Deque i.e Monotonic Stack 
class Solution {
    public int[] maxSlidingWindow(int[] nums, int k) {
         Deque<Integer>q=new ArrayDeque<>();
         int n=nums.length;
            int[] r = new int[n - k + 1];
            int ri = 0;
         for(int i=0;i<nums.length;i++){
            if(!q.isEmpty() && q.peek()==i-k){
                q.poll();
            }
                while(!q.isEmpty() && nums[q.peekLast()]<nums[i]){
                    q.pollLast();
                }
                q.offer(i);
                if(i>=k-1){
                    r[ri++]=nums[q.peek()];
                }
            }
                return r;
         }
}

//The Celebrity Problem
https://www.geeksforgeeks.org/problems/the-celebrity-problem/1
//M-1
class Solution {
    public int celebrity(int mat[][]) {
        int n=mat.length;
        int[] knowMe = new int[n];
        int[] Iknow = new int[n];
        
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                if (i!=j && mat[i][j] == 1) {
                    knowMe[j]++;
                    Iknow[i]++;
                }
            }
        }

        for (int i = 0; i < n; i++) {
            if (knowMe[i] == n - 1 && Iknow[i] == 0) {
                return i;
            }
        }
        return -1;
    }
}
