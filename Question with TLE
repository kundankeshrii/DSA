//questions is solved using recursion but it gives TLE
//All questions will be Solved soon Through Dynamic Programming (DP)

//https://leetcode.com/problems/house-robber/description/
//M-1
class Solution {
    public int rob(int[] nums) {
        return homeRob(nums,0);
    }
         private int homeRob(int[] nums,int idx){
                if(idx>=nums.length){
                    return 0;
                }
        int option1=nums[idx]+homeRob(nums,idx+2);
        int option2=0+homeRob(nums,idx+1);
        return Math.max(option1,option2);

    }
}

//https://www.geeksforgeeks.org/problems/cutted-segments1642/1
//Question is based on Maximize the cut in line Segment


class Solution {
    
    public int maximizeCuts(int n, int x, int y, int z) {
        if(n==0) return 0;
        if(n<0){
            return Integer.MIN_VALUE;
        }
        
        int option1=1+maximizeCuts(n-x,x,y,z);
        int option2=1+maximizeCuts(n-y,x,y,z);
        int option3=1+maximizeCuts(n-z,x,y,z);
        int max=Math.max(option1,option2);
        int result=Math.max(max,option3);
         return result;
    }
}


//https://leetcode.com/problems/partition-equal-subset-sum/

class Solution {
    public boolean canPartition(int[] nums) {
        int n = nums.length;

        // Step 1: Calculate total sum
        int totalSum = 0;
        for (int num : nums) {
            totalSum += num;
        }

        // Step 2: If total sum is odd, can't split equally
        if (totalSum % 2 != 0) {
            return false;
        }

        // Step 3: Check if a subset with sum = totalSum/2 exists
        return equalPartition(nums, n, totalSum / 2);
    }

    private boolean equalPartition(int[] arr, int N, int targetSum) {
        // Base cases
        if (targetSum == 0) return true;
        if (N == 0) return false;

        // If current element is greater than target, skip it
        if (arr[N - 1] > targetSum) {
            return equalPartition(arr, N - 1, targetSum);
        }

        // Either include current element or exclude it
        return equalPartition(arr, N - 1, targetSum)
            || equalPartition(arr, N - 1, targetSum - arr[N - 1]);
    }
}


//https://www.geeksforgeeks.org/problems/subset-sum-problem-1611555638/1

class Solution {

    static Boolean isSubsetSum(int arr[], int sum) {
        return SubsetSum(arr,arr.length,sum);
    }
        private static boolean SubsetSum(int[] arr,int n,int sum){
        if(sum==0) return true;
        if(n==0) return false;
         if(arr[n-1]>sum){
        return SubsetSum(arr,n-1,sum);
         }
        return SubsetSum(arr,n-1,sum) || SubsetSum(arr,n-1,sum-arr[n-1]);
    
        
    }
}


//https://leetcode.com/problems/longest-common-subsequence/description/

class Solution {
    public int longestCommonSubsequence(String text1, String text2) {
        int m=text1.length();
        int n=text2.length();
        return lcs(text1,text2, m, n);
    }
    private int lcs(String str1,String str2,int m,int n){
        if(m==0|| n==0){
            return 0;

        }
        if(str1.charAt(m-1)==str2.charAt(n-1)){
            return 1+lcs(str1,str2,m-1,n-1);
        }else{
           return Math.max(lcs(str1,str2,m,n-1),lcs(str1,str2,m-1,n));
        }
         
    }
}

//https://leetcode.com/problems/edit-distance/description/
class Solution {
    public int minDistance(String word1, String word2) {
        int m=word1.length();
        int n=word2.length();
        return MD(word1,word2,m,n);
    }
    private int MD(String str1,String str2,int m,int n){
        if(m==0 )return n;
        if(n==0) return m;
        if(str1.charAt(m-1)==str2.charAt(n-1)){
            return MD(str1,str2,m-1,n-1);

        }else{
            return 1 + Math.min(
            MD(str1, str2, m, n - 1),     
            Math.min(
                MD(str1, str2, m - 1, n), 
                MD(str1, str2, m - 1, n - 1)
            )
            );
    }
    }
}

//https://leetcode.com/problems/coin-change/description/

class Solution {
    public int coinChange(int[] coins, int amount) {
        int result= getMin(coins,coins.length,amount);
        return result==Integer.MAX_VALUE ? -1 : result;
    }
    private int getMin(int[] coins,int n,int S){
        if(S==0) return 0;
        int result=Integer.MAX_VALUE;
         for(int i=0;i<n;i++){

                if(coins[i]<=S){
                    int sub_result=getMin(coins,n,S-coins[i]);
                
                                if(sub_result!=Integer.MAX_VALUE){
                                    result=Math.min(sub_result+1,result);
                }
         }
        
    }
    return result;
}
}

//https://leetcode.com/problems/jump-game-ii/description/
class Solution {
    public int jump(int[] nums) {
        return minJump(nums,nums.length-1);
    }
    private int minJump(int[] arr,int n){
        if(n==0) return 0;
        int result =Integer.MAX_VALUE;
        for(int i=0;i<n;i++){
            if(i+arr[i]>=n){
                int sub_result=minJump(arr,i);
                if(sub_result!=Integer.MAX_VALUE)
                result=Math.min(result,sub_result+1);
            }
        }
            return result;
    }
}
